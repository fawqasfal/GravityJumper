diff --git a/core/src/com/mygdx/gravity/Enemy.java b/core/src/com/mygdx/gravity/Enemy.java
index 876490d..1b2a8c0 100644
--- a/core/src/com/mygdx/gravity/Enemy.java
+++ b/core/src/com/mygdx/gravity/Enemy.java
@@ -1,5 +1,5 @@
 package com.mygdx.gravity;
-
+import java.util.*;
 import com.badlogic.gdx.math.Rectangle;
 import com.badlogic.gdx.graphics.g2d.TextureRegion;
 import com.badlogic.gdx.graphics.Texture;
@@ -11,17 +11,33 @@ public class Enemy {
 	TextureRegion defImage;
 	int damage;
 	int give;
+	float velocity;
+	float acceleration = 50f;
+	float slowdown = 0.000002f; 
+	//how long have we been moving in either left/right or up/down. 
+	//every time move in the same direction, add 1 (up/right), or -1 (left/down). 
+	//every time change, set to 1 (up/right) or -1 (left/down)
+
 	boolean alive; 
 
 	public final static String DEFAULT_IMAGE = "enemy.png";
 	public final static float DEFAULT_SIZE = 16;
-	public final static float SCALE = 4.5f;
-	public final static int MOVE_AMT = 100;
+	public final static int MIN_DMG = 5;
+	public final static int MAX_DMG = 10;
+	public final static int MIN_GIVE = 50;
+	public final static int MAX_GIVE = 100;
+	public final static float SCALE = 3.5f;
+	public final static float MOVE_AMT_X = 3f;
+	public final static float MOVE_AMT_Y = 2f;
+	public final static int MAX_X = 0;
+	public final static int MAX_Y = 0;
+
 	public Enemy(float spawnX, float spawnY, int dmg, int give) {
 		//It takes a nation of millions to hold us back.
 		this.rectRep = new Rectangle(spawnX, spawnY, SCALE * DEFAULT_SIZE, SCALE * DEFAULT_SIZE);
 		this.defImage = new TextureRegion(new Texture(Gdx.files.internal(DEFAULT_IMAGE)));
-		this.damage = damage;
+		this.damage = dmg;
+		
 		this.give = give;
 		this.alive = true;
 	}
@@ -32,24 +48,27 @@ public class Enemy {
 		this.defImage = null;
 	}
 
-	public void floatLeft(int amt) {
-		this.rectRep.x -= amt;
-		floatY(amt);	
-	}
+	public void move(float amtX, float amtY, Hero hero) {
+		//will angrily shake while trying to reach hero
+		this.rectRep.x += amtX;
+		this.rectRep.y += amtY;
+		this.velocity += this.acceleration;
+		this.rectRep.x += slowdown * Math.random() * velocity * (hero.rectRep.x - this.rectRep.x);
+		this.rectRep.y += slowdown * Math.random() * velocity * (hero.rectRep.y - this.rectRep.y);
 
-	public void floatRight(int amt) {
-		this.rectRep.x += amt;
-		floatY(amt);
 	}
 
-	public void floatY(int amt) {
-		int direction = randrange(-1,2);
-		this.rectRep.y += direction * Math.log(amt) / Math.log(2);
-	}
+	public boolean collide(Platform platform) {
+		if (this.collide(platform.rectRep)) {
 
-	public int randrange(int low, int high) {
-		//[low, high)
-		return low + (int) Math.floor(Math.random() * (high - low));
+			return true;
+		} else{
+			return false;
+		}
 	}
-	
+	public boolean collide(Rectangle object) {
+		boolean intersects = (this.rectRep.x <= object.x + object.width && this.rectRep.x + this.rectRep.width >= object.x && 
+					  this.rectRep.y <= object.y + object.height && this.rectRep.y + this.rectRep.height >= object.y);
+		return intersects;
+	}	
 }
\ No newline at end of file
diff --git a/core/src/com/mygdx/gravity/Hero.java b/core/src/com/mygdx/gravity/Hero.java
index e1ba3d4..60d0aca 100644
--- a/core/src/com/mygdx/gravity/Hero.java
+++ b/core/src/com/mygdx/gravity/Hero.java
@@ -13,11 +13,12 @@ public class Hero {
 	boolean isJumping;
 	int vDirection;
 	int hDirection;
-	int coin; 
+	int coin = HEALTH; 
 	int curr = 0;
 	long sinceLast;
 	float velocity = INIT_V;
 
+	public static final int HEALTH = 1000;
 	public static final int FEET_UP = 1;
 	public static final int FEET_DOWN = -1;
 	public static final String DEFAULT_MOVE_LEFT_IMAGE = "leftmove.png";
@@ -28,11 +29,11 @@ public class Hero {
 	public static final int DEFAULT_IMG_HEIGHT = 31;
 	public static final float SCALE = 4.5f;
 	public static final float FRAMES_PER_SECOND = 0.12f;
-	public static final float GRAVITY = 25f;
+	public static final float GRAVITY = 30f;
 	public static final float INIT_V = 0;
 	public static final int LEFT = 1;
 	public static final int RIGHT = 0;
- 	public static final int MOVE_AMT = 300;
+ 	public static final int MOVE_AMT = 600;
 
 	public Hero(float x, float y, float imgX, float imgY, float width, float height, 
 				Texture moveLeftSheet, Texture moveRightSheet) {
@@ -50,33 +51,6 @@ public class Hero {
 			new Texture(Gdx.files.internal(DEFAULT_MOVE_RIGHT_IMAGE)));
 	}
 
-	public TextureRegion[][] setSheets(Texture moveLeftSheet, Texture moveRightSheet) {
-		//breaks sprite sheets into Animations.
-		TextureRegion[] moveLeft = new TextureRegion[12];
-		TextureRegion[] moveRight = new TextureRegion[12];
-		TextureRegion[] moveLeftFlipped = new TextureRegion[12];
-		TextureRegion[] moveRightFlipped = new TextureRegion[12];
-		int l_startX = 0;
-		int r_endX = 0; //idiosyncracies in these specific frames
-		for (int i = 0; i < 12; i++) {
-			if (i >= 2 && i <= 4) l_startX = -1; //idiosyncracies in this specific frame 
-			if (i == 3) r_endX = 1; 
-			moveLeft[i] = new TextureRegion(moveLeftSheet, 32 * i + DEFAULT_START_X + l_startX, DEFAULT_START_Y,
-				DEFAULT_IMG_WIDTH + -1 * l_startX, DEFAULT_IMG_HEIGHT);
-
-			moveLeftFlipped[i] = new TextureRegion(moveLeft[i]);
-			moveLeftFlipped[i].flip(false, true);
-			moveRight[i] = new TextureRegion(moveRightSheet, 32 * i + DEFAULT_START_X + r_endX, DEFAULT_START_Y,
-				DEFAULT_IMG_WIDTH + r_endX, DEFAULT_IMG_HEIGHT);
-
-			moveRightFlipped[i] = new TextureRegion(moveRight[i]);
-			moveRightFlipped[i].flip(false, true);
-		}
-
-		TextureRegion[][] answer = {moveLeft, moveRight, moveLeftFlipped, moveRightFlipped}; 
-		return answer;
-	}
-
 	public void chooseTexture() {
 			this.currImage = this.textureRegions[this.vDirection + this.hDirection + 1][curr];
 	}
@@ -108,6 +82,10 @@ public class Hero {
  			sinceLast = 0;
 		}
 	}
+
+	public void moveVert(float amt) {
+		this.rectRep.y += amt;
+	}
 	public void stabilize() {
 		this.curr = 0;
 		this.sinceLast = 0;
@@ -125,42 +103,39 @@ public class Hero {
 		return this.velocity;		
 	}
 
-
-	public boolean collides(Rectangle object) {
-		boolean intersects;
-		Rectangle rect = this.rectRep;
-		intersects = (rect.x + rect.width < object.x || object.x + object.width < rect.x 
-			|| object.y + object.height < rect.y || rect.y + rect.height < object.y);
-		return !intersects;
-	}
-
-	public boolean collides(Enemy enemy) {
-		boolean loseCoin  = false;
-		if (this.collides(enemy.rectRep)) {
-			if (this.vDirection * enemy.rectRep.y < this.vDirection * this.rectRep.y)
-				loseCoin = true;
-		}
-		if (loseCoin) loseCoin(enemy.damage);
-		else {
-			gainCoin(enemy.give);
-			enemy.die();
-			//bounce-back
-			this.jump();
-		}
-		return loseCoin;
-	}
-
 	public void gainCoin(int amt) {
 		this.coin += amt;
-		System.out.println(coin);
 	}
 
 	public void loseCoin(int amt) {
 		this.coin -= amt;
-		System.out.println(coin);
 	}
- 	public boolean collides(Platform platform) {
-		if (this.collides(platform.rectRep)) {
+
+	public boolean collide(Rectangle object) {
+		boolean intersects = (this.rectRep.x <= object.x + object.width && this.rectRep.x + this.rectRep.width >= object.x && 
+					  this.rectRep.y <= object.y + object.height && this.rectRep.y + this.rectRep.height >= object.y);
+		return intersects;
+	}
+
+
+	public boolean collide(Enemy enemy) {
+		boolean loseCoin  = true;
+		if (this.collide(enemy.rectRep)) {
+			if ((vDirection == FEET_UP && rectRep.y < enemy.rectRep.y) || 
+				(vDirection == FEET_DOWN && enemy.rectRep.y < rectRep.y))
+				loseCoin = false;
+			if (loseCoin) loseCoin(enemy.damage);
+			else { 
+				gainCoin(enemy.give);
+				this.jump();
+				enemy.die();
+			}
+
+		}
+		return loseCoin;
+	}
+ 	public boolean collide(Platform platform) {
+		if (this.collide(platform.rectRep)) {
 			this.isJumping = false;
 			if (this.vDirection == FEET_UP) {
 				this.rectRep.y = platform.rectRep.y - this.rectRep.height;
@@ -178,4 +153,36 @@ public class Hero {
 		//GET WRECKED! 
 		return this.rectRep;
 	}
+
+	public TextureRegion[][] setSheets(Texture moveLeftSheet, Texture moveRightSheet) {
+		//breaks sprite sheet textures into 2darray with flipped sheets as well
+
+		//this whole method breaks my heart. thats why i put it at the bottom. ugly piece of shit. no one likes you. youre at the bottom,
+		//like an untouchable in the ancient indian caste system.
+		// i wish i had more time to implement something more generalizible.
+		//but this game simply doesnt have that scope and im late as it is. 
+		TextureRegion[] moveLeft = new TextureRegion[12];
+		TextureRegion[] moveRight = new TextureRegion[12];
+		TextureRegion[] moveLeftFlipped = new TextureRegion[12];
+		TextureRegion[] moveRightFlipped = new TextureRegion[12];
+		int l_startX = 0;
+		int r_endX = 0; //idiosyncracies in these specific frames
+		for (int i = 0; i < 12; i++) {
+			if (i >= 2 && i <= 4) l_startX = -1; //idiosyncracies in this specific frame 
+			if (i == 3) r_endX = 1; 
+			moveLeft[i] = new TextureRegion(moveLeftSheet, 32 * i + DEFAULT_START_X + l_startX, DEFAULT_START_Y,
+				DEFAULT_IMG_WIDTH + -1 * l_startX, DEFAULT_IMG_HEIGHT);
+
+			moveLeftFlipped[i] = new TextureRegion(moveLeft[i]);
+			moveLeftFlipped[i].flip(false, true);
+			moveRight[i] = new TextureRegion(moveRightSheet, 32 * i + DEFAULT_START_X + r_endX, DEFAULT_START_Y,
+				DEFAULT_IMG_WIDTH + r_endX, DEFAULT_IMG_HEIGHT);
+
+			moveRightFlipped[i] = new TextureRegion(moveRight[i]);
+			moveRightFlipped[i].flip(false, true);
+		}
+
+		TextureRegion[][] answer = {moveLeft, moveRight, moveLeftFlipped, moveRightFlipped}; 
+		return answer;
+	}
 }
diff --git a/core/src/com/mygdx/gravity/MainGameScreen.java b/core/src/com/mygdx/gravity/MainGameScreen.java
index 98438cc..aafe1f0 100644
--- a/core/src/com/mygdx/gravity/MainGameScreen.java
+++ b/core/src/com/mygdx/gravity/MainGameScreen.java
@@ -5,107 +5,171 @@ import com.badlogic.gdx.*;
 import com.badlogic.gdx.math.*;
 import com.badlogic.gdx.audio.*;
 import com.badlogic.gdx.graphics.*;
-import com.badlogic.gdx.Input.*;;
+import com.badlogic.gdx.Input.*;
 import com.badlogic.gdx.graphics.g2d.*;
 import com.badlogic.gdx.utils.*;
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer; 
 import com.badlogic.gdx.graphics.glutils.ShapeRenderer.ShapeType;
 
 public class MainGameScreen extends ScreenAdapter {
-	MainGravity game;
-	Texture bgImage;
-	Texture platform;
-	Hero hero;
-	Music gameMusic;
+	MainGravity game; //has the spritebatch that does the drawing that we will be needing
+	Hero hero; 
+	Music gameMusic; 
 	OrthographicCamera camera;
-	public static Array<Platform> platforms; 
-	int w = MainGravity.WIDTH;
+	Array<Platform> platforms; 
+	Array<Enemy> enemies;
+	int w = MainGravity.WIDTH; //dimensions of camera. default set to the dimensions of game screen if player doesnt change it
 	int h = MainGravity.HEIGHT;
-	ShapeRenderer shapeRenderer; //debugging purposes
-	
-	public MainGameScreen(MainGravity game) {
-		this.game = game; //has the spritebatch that does the drawing that we will be needing
+	ShapeRenderer shapeRenderer; 
+	//debugging-renders the game's rectangles (characters without textures) with yellow lines in the bottom 1/8th of the screen  
 
-		camera = new OrthographicCamera(); //p.o.v of game world
+	public static final int MAX_ENEMY_AMT = 10;
+	public static final float ENEMY_DENSITY_RATE = 0.4f;
+	public static final float LEAST_Y = Platform.DEFAULT_IMAGE_HEIGHT * Platform.SCALE; 
+	public static final float MOST_Y  = MainGravity.HEIGHT - LEAST_Y; 
+	public static final float DEBUG_SIZE_CONSTANT = 0.25f;
+	public MainGameScreen(MainGravity game) {
+		this.game = game; 
+		camera = new OrthographicCamera(); 
    		camera.setToOrtho(false, w, h); 
-   		/*false just means that highest point of camera-world = h and lowest point = 0, instead of the other way around as it was
-   		with TextureRegions*/
+   		/*false just means render the game world as if the bottom of the screen was 0 and the top of the screen was height, 
+   		as opposed to top-down, which is how Rectangles work*/
+   		shapeRenderer = new ShapeRenderer(); 
+		gameMusic = Gdx.audio.newMusic(Gdx.files.internal("music.mp3")); //Music objects auto-loop, as opposed to Sound objects
+		platforms = new Array<Platform>(); //Array is libgdx's "better" ArrayList i guess thats what they say
+		platformSpawner();
+		enemies = new Array<Enemy>();
+		hero = new Hero((MainGravity.WIDTH - Hero.DEFAULT_IMG_WIDTH * Hero.SCALE) / 2, 
+						Platform.DEFAULT_IMAGE_HEIGHT * Platform.SCALE); //spawns hero in the middle on top of a platform
+		//SCALE because DEFAULT_IMAGE_WIDTH deals with the 16x16 sprite sheet, but we want player to see something a bit bigger
+	}
 
-   		shapeRenderer = new ShapeRenderer(); //renders the rectangle objects as opposed to textures. for debugging
-	
-		//sound
-		gameMusic = Gdx.audio.newMusic(Gdx.files.internal("music.mp3"));		
-		//platforms
-		platforms = new Array<Platform>();
-		for (int i = 0; i < w; i += Platform.DEFAULT_IMAGE_WIDTH * Platform.SCALE) {
+	public void platformSpawner() {
+		for (int i = 0; i < w; i += Platform.DEFAULT_IMAGE_WIDTH * Platform.SCALE) { 
 			platforms.add(new Platform(i,0));
-			platforms.add(new Platform(i, MainGravity.HEIGHT - Platform.DEFAULT_IMAGE_HEIGHT * Platform.SCALE));
+			platforms.add(new Platform(i, MainGravity.HEIGHT - Platform.DEFAULT_IMAGE_HEIGHT * Platform.SCALE)); //top of screen
 		}
+	}
+
+	public void birthEnemy(float leastX, float mostX, float leastY, float mostY) {
+		float spawnX = leastX + new Random().nextFloat() * (mostX - leastX);
+		float spawnY = leastY + new Random().nextFloat() * (mostY - leastY);
 
-		//hero
-		hero = new Hero(0, platforms.get(0).getRect().height);
+		int damage = Enemy.MIN_DMG + new Random().nextInt(Enemy.MAX_DMG - Enemy.MIN_DMG);
+		int give = Enemy.MIN_GIVE + new Random().nextInt(Enemy.MAX_GIVE - Enemy.MIN_GIVE);
+	
+		Enemy newBaby = new Enemy(spawnX, spawnY, damage, give);
+
+		enemies.add(newBaby);
+	}
 
+	public void enemySpawner() {
+		if (enemies.size < MAX_ENEMY_AMT && Math.random() < ENEMY_DENSITY_RATE)
+			birthEnemy(0, MainGravity.WIDTH, LEAST_Y, MOST_Y);
 	}
 
-	public void render (float delta) {
-		camera.update();
+	public void handleCollisions() {
+		 for (Platform platform : platforms)
+			hero.collide(platform); //stops jumping
+		for (Enemy enemy : enemies) {
+				hero.collide(enemy); //gets or loses health
+				if (!enemy.alive)
+					enemies.removeValue(enemy, true);
+		}
+	}
+
+	public void tooFarCheck() {
+		//if objects moves too far right, loop him back to the left side of screen. same with up/down
+		for (Enemy enemy : enemies) {
+				tooFarCheck(enemy.rectRep);
+		}
+		tooFarCheck(hero.rectRep);
+	}
+
+	public void tooFarCheck(Rectangle x) {
+		if (x.y > MainGravity.HEIGHT)
+			x.y = 0;
+		if (x.y < 0)
+			x.y = MainGravity.HEIGHT;
+		if (x.x > MainGravity.WIDTH)
+			x.x = 0; 
+		if (x.x + x.width < 0)
+			x.x = MainGravity.WIDTH; //offset to make it look prettier
+	}
+
+	public void renderSetup() {
+		camera.update(); //every frame
 		Gdx.gl.glClearColor(135f / 255f, 206f / 255f, 250f / 255f, 1); //sky blue
 		Gdx.gl.glClear(GL20.GL_COLOR_BUFFER_BIT); //something OpenGL needs to do, who knows
- 		inputHandler();
-		game.batch.setProjectionMatrix(camera.combined);
+		game.batch.setProjectionMatrix(camera.combined); //something for going from GPU's color-bit matrices to pixels on screen?
 		shapeRenderer.setProjectionMatrix(camera.combined); 
-		//something for going from GPU's color-bit matrices to pixels on screen? or something
 		shapeRenderer.begin(ShapeType.Line); //ShapeType.Line vs ShapeType.Fill
 		shapeRenderer.setColor(1, 1, 0, 1); //yellow debug outer lines on the rects	
+	}
 
-		for (Platform platform : platforms)
-			hero.collides(platform); //stops jumping
-		if (hero.isJumping) hero.getRect().y += hero.jumpIter(Hero.GRAVITY) * Gdx.graphics.getDeltaTime();
-		if (hero.getRect().y > MainGravity.HEIGHT)
-			hero.getRect().setY(0);
-		if (hero.getRect().y < 0)
-			hero.getRect().setY(MainGravity.HEIGHT + hero.getRect().height);
-
+	public void renderObjects() {
  		game.batch.begin();
  			for (Platform platform : platforms) 
  				render(platform.getImage(), platform.getRect().x, platform.getRect().y, 
  					platform.getRect().width, platform.getRect().height);
+ 			
  			hero.chooseTexture();
  			render(hero.currImage, hero.getRect().x, hero.getRect().y, hero.getRect().width, hero.getRect().height);
-
+ 			for (Enemy enemy : enemies)
+ 					render(enemy.defImage, enemy.rectRep.x, enemy.rectRep.y, enemy.rectRep.width, enemy.rectRep.height);
+ 			String money = new String();
+ 			if  (hero.coin < 0) money = "(DEBT!)";
+ 			game.font.draw(game.batch,"MONEY : " + hero.coin + money, 0f, MainGravity.HEIGHT - 50f);
    		game.batch.end();
 		shapeRenderer.end();
 	}
 
+	public void render(float delta) {
+		inputHandler();
+		enemySpawner();
+		handleMovement();
+		handleCollisions();
+		tooFarCheck();
+		renderSetup();
+		renderObjects();
+	}
+
 	public void render(TextureRegion image, float x, float y, float width, float height) {
+		//renders to spritebatch and debugger
 		game.batch.draw(image, x, y, width, height);
-		shapeRenderer.rect((x / 4), (y / 4), (width / 4), (height / 4)); //debug render is in the bottom left, at 1/8th the size
+		shapeRenderer.rect((x * DEBUG_SIZE_CONSTANT), (y * DEBUG_SIZE_CONSTANT), 
+						   (width * DEBUG_SIZE_CONSTANT), (height  * DEBUG_SIZE_CONSTANT)); 
 	}
 
-	public void inputHandler() {
+	public boolean should_animate() {
 		boolean animate = false;
 		for (Platform platform : platforms) 
-			if (hero.collides(platform)) {
+			if (hero.collide(platform)) {
 				animate = true;
 				break;
-			}	
-		if(Gdx.input.isKeyPressed(Keys.LEFT)) {
+			}
+		return animate;
+	}
+	public void handleMovement() {
+		if (hero.isJumping) 
+			hero.moveVert(hero.jumpIter(Hero.GRAVITY) * Gdx.graphics.getDeltaTime()); //time since last frame
+		for (Enemy enemy : enemies) {
+			enemy.move((-0.5f + (float)Math.random()) * 20f, (-0.5f + (float)Math.random()) * 10f, hero);
+
+		}
+	}
+	public void inputHandler() {	
+		boolean animate = should_animate();
+		if(Gdx.input.isKeyPressed(Keys.A)) 
  			hero.moveLeft(Hero.MOVE_AMT * Gdx.graphics.getDeltaTime(), animate);
- 			if (hero.getRect().x + hero.getRect().width < 0)
- 				hero.getRect().setX(MainGravity.WIDTH);
- 		}
-		else if(Gdx.input.isKeyPressed(Keys.RIGHT)) {
+		else if(Gdx.input.isKeyPressed(Keys.D)) 
  			hero.moveRight(Hero.MOVE_AMT * Gdx.graphics.getDeltaTime(), animate);
- 			if (hero.getRect().x > MainGravity.WIDTH) 
-				hero.getRect().x = -10;
- 		}
- 		else {
+ 		else 
  			hero.stabilize();
- 		}
 
- 		if (Gdx.input.isKeyPressed(Keys.UP) || Gdx.input.isKeyPressed(Keys.DOWN)) {
+ 		if (Gdx.input.isKeyPressed(Keys.W) || Gdx.input.isKeyPressed(Keys.S)) 
  			if (!hero.isJumping) hero.jump();
- 		}
+ 		
 	}
 	public void dispose() {
 	     game.batch.dispose();
diff --git a/core/src/com/mygdx/gravity/MainMenuScreen.java b/core/src/com/mygdx/gravity/MainMenuScreen.java
index 201c47a..549ff5a 100644
--- a/core/src/com/mygdx/gravity/MainMenuScreen.java
+++ b/core/src/com/mygdx/gravity/MainMenuScreen.java
@@ -3,7 +3,7 @@ package com.mygdx.gravity;
 import com.badlogic.gdx.Gdx;
 import com.badlogic.gdx.graphics.GL20;
 import com.badlogic.gdx.graphics.OrthographicCamera;
-
+import com.badlogic.gdx.Input.*;
 public class MainMenuScreen extends ScreenAdapter {
 	final MainGravity game;
 	OrthographicCamera camera;
@@ -25,13 +25,13 @@ public class MainMenuScreen extends ScreenAdapter {
 
         game.batch.begin();
         game.font.draw(game.batch, "Welcome to Gravity Jump", (w / 2) - 150, (h / 2) + 100);
-        game.tutFont.draw(game.batch, "Move with left/right, flip your gravity with up/down, punch enemies with Enter.", 
+        game.tutFont.draw(game.batch, "Move with left/right, flip your gravity with up/down, hit enemies with your foot to kill them.", 
             (w / 2) - 360,
             (h / 2) + 50);
-        game.font.draw(game.batch, "CLICK ANYWHERE TO BEGIN", (w / 2) - 150, h / 2);
+        game.font.draw(game.batch, "CLICK ANYWHERE OR PRESS ENTER TO BEGIN", (w / 2) - 175, h / 2);
         game.batch.end();
 
-        if (Gdx.input.isTouched()) {
+        if (Gdx.input.isTouched() || Gdx.input.isKeyPressed(Keys.ENTER)) {
         	game.setScreen(new MainGameScreen(game));
         	dispose();
         }
